// Copyright 2024 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef THIRD_PARTY_ODML_LITERT_LITERT_TEST_GENERATORS_EXAMPLE_H_
#define THIRD_PARTY_ODML_LITERT_LITERT_TEST_GENERATORS_EXAMPLE_H_

#include <array>
#include <cstddef>
#include <cstdint>
#include <string>
#include <utility>
#include <vector>

#include "absl/strings/string_view.h"  // from @com_google_absl
#include "litert/c/litert_op_code.h"
#include "litert/cc/litert_buffer_ref.h"
#include "litert/cc/litert_c_types_printing.h"  // IWYU pragma: keep
#include "litert/cc/litert_detail.h"
#include "litert/cc/litert_element_type.h"
#include "litert/cc/litert_expected.h"
#include "litert/cc/litert_layout.h"
#include "litert/cc/litert_macros.h"
#include "litert/cc/litert_rng.h"
#include "litert/core/model/model.h"
#include "litert/test/generators/common.h"
#include "litert/test/generators/graph_helpers.h"
#include "litert/test/rng_fixture.h"
#include "litert/test/simple_buffer.h"
#include "tflite/schema/schema_generated.h"

namespace litert::testing {

// Reference cts test logic implementation that does simply returns the input.
// Used as an example and to sanity check the framework.
//
// Note: Template parameters for all test logics define the axis of
// configurability on which we want to explicitly *enumerate* values for
// (rather than randomly generate them). This is appropriate for paramters
// where the space of possible values is small and known (e.g. types, ranks).
//    In order to work with the combinatorial parameter expand/specialize
// utilities, the template params cannot not be non-type, but these can
// be simulated simply with a standard std::integral_constant.
template <typename Rank, typename T>
struct ExampleTestLogic {
 private:
  // Used by by random tensor shape generator to cap the size of the tensor.
  static constexpr size_t kMaxTensorSize = 1024;

  static_assert(std::is_same_v<typename Rank::value_type, size_t>);
  // Rank of the input and output tensor.
  static constexpr size_t kRank = Rank::value;

  // Names of the input and output tensor.
  static constexpr TensorNames<1> kInputNames = {"input"};
  static constexpr TensorNames<1> kOutputNames = {"output"};

  // Signature name of the model.
  static constexpr absl::string_view kSignatureName = "default";

  // The compliment of the "enumerated" template parameters. A "params"
  // typed is defined by all test logics and encapsulates all of the paramters
  // of this test that are randomly generated. This is suitable for larger
  // and practically unbounded spaces (like shapes).
  struct Params {
    std::array<Layout::Dim, kRank> shape;
  };

  // Utility for mapping litert ops to corresponding tflite schema types.
  using FbTypes = FbOpTypes<kLiteRtOpCodeTflAdd>;

 public:
  // Litert element type enum taken from c++ type T.
  static constexpr ElementType kElementType = GetElementType<T>();

  // Defines consituent types needed by the driver code. All test logics
  // must have one of these as a public member type.
  using Traits = TestLogicTraits<TypeList<T>, TypeList<T>, Params>;

  // A common name for all tests generated by this logic. This should
  // describe the non-random parameters (see template).
  static absl::string_view Name() { return "NoOp"; }

  // Given an instance of random params, construct the graph under test.
  Expected<LiteRtModelT::Ptr> BuildGraph(const Params& params) {
    const std::vector<int32_t> dims(params.shape.begin(), params.shape.end());

    std::vector<TensorDetails> inputs(2);
    std::vector<TensorDetails> outputs(1);

    inputs[0] = TensorDetails{dims, LiteRtElementType(kElementType),
                              std::string(kInputNames[0])};

    const T cst_data = 0;
    inputs[1] = TensorDetails{
        {},
        LiteRtElementType(kElementType),
        "cst",
        OwningBufferRef<uint8_t>(reinterpret_cast<const uint8_t*>(&cst_data),
                                 sizeof(T))};

    outputs[0] = TensorDetails{dims, LiteRtElementType(kElementType),
                               std::string(kOutputNames[0])};

    return SingleOpModel<kLiteRtOpCodeTflAdd>(
        inputs, outputs, ::tflite::ActivationFunctionType_NONE,
        /*pot_scale_int16=*/false);
  }

  // Generate an instance of the random params for this test logic with the
  // given random device.
  template <typename Rng>
  Expected<Params> GenerateParams(Rng& rng) {
    RandomTensorType<kRank, kMaxTensorSize, LiteRtElementType(kElementType)>
        type;
    LITERT_ASSIGN_OR_RETURN(const auto tensor_type, type(rng));
    Params p;
    std::copy(std::cbegin(tensor_type.layout.dimensions),
              std::cbegin(tensor_type.layout.dimensions) + kRank,
              std::begin(p.shape));
    return p;
  }

  // Initialize input buffers with random data, these will be passed to the
  // compiled model api.
  template <typename Rng>
  Expected<typename Traits::InputBuffers> MakeInputs(Rng& rng,
                                                     const Params& params) {
    LITERT_ASSIGN_OR_RETURN(auto input, SimpleBuffer::Create<T>(params.shape));
    LITERT_RETURN_IF_ERROR(
        (input.template WriteRandom<T, DummyGenerator>(rng)));
    return typename Traits::InputBuffers{std::move(input)};
  }

  // Initialize output buffers, these will be passed to the compiled model api.
  Expected<typename Traits::OutputBuffers> MakeOutputs(const Params& params) {
    LITERT_ASSIGN_OR_RETURN(auto output, SimpleBuffer::Create<T>(params.shape));
    return typename Traits::OutputBuffers{std::move(output)};
  }

  // Reference implementation which the driver code will compare the actual
  // results against.
  Expected<void> Reference(const Params& params,
                           const Traits::ReferenceInputs& inputs,
                           Traits::ReferenceOutputs& outputs) {
    auto [input] = inputs;
    auto [output] = outputs;
    const size_t num_elements = output.NumElements();
    for (size_t i = 0; i < num_elements; ++i) {
      output.data[i] = input.data[i];
    }
    return {};
  }
};

}  // namespace litert::testing

#endif  // THIRD_PARTY_ODML_LITERT_LITERT_TEST_GENERATORS_EXAMPLE_H_
